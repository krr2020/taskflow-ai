/**
 * Markdown Display for Terminal
 *
 * Renders markdown content in terminal with proper formatting.
 */

import { marked } from "marked";
import TerminalRenderer from "marked-terminal";
import pc from "picocolors";

// ANSI escape code pattern for stripping
// biome-ignore lint/suspicious/noControlCharactersInRegex: ANSI escape sequences are intentional
const ANSI_PATTERN = /\u001b\[\d+m/g;

let renderer: TerminalRenderer | null = null;

/**
 * Initialize the terminal renderer
 */
function initRenderer(): void {
	if (renderer) return;

	renderer = new TerminalRenderer({
		// Code block styling
		code: pc.yellow,
		blockquote: pc.gray,

		// Heading styling
		heading: pc.bold,
		firstHeading: pc.bold,

		// List styling
		listitem: pc.white,
		list: (body: string) => body,

		// Text styling
		strong: pc.bold,
		em: pc.italic,
		codespan: pc.yellow,
		del: pc.strikethrough,

		// Link styling
		link: pc.cyan,
		href: pc.blue,

		// Table styling
		table: (header: string, body: string) => header + body,
		tablerow: (content: string) => `${content}\n`,
		tablecell: (content: string) => `${content} `,

		// Other
		hr: () => `${pc.gray("â”€".repeat(60))}\n`,
		br: "\n",
		paragraph: (text: string) => `${text}\n`,

		// Formatting options
		tab: 2,
		width: 80,
		reflowText: true,
		showSectionPrefix: false,
		unescape: true,
		// biome-ignore lint/suspicious/noExplicitAny: TerminalRenderer options need any
	} as any);

	// Configure marked to use our terminal renderer
	marked.setOptions({
		// biome-ignore lint/suspicious/noExplicitAny: marked options need any for custom renderer
		renderer: renderer as any,
	});
}

export const MarkdownDisplay = {
	/**
	 * Render markdown to terminal-friendly format
	 *
	 * @example
	 * const output = MarkdownDisplay.render('# Hello\n\nThis is **bold** text');
	 * console.log(output);
	 */
	render(markdown: string): string {
		initRenderer();

		try {
			return marked.parse(markdown) as string;
		} catch (error) {
			// If rendering fails, return original markdown
			console.error("Markdown rendering failed:", error);
			return markdown;
		}
	},

	/**
	 * Create a streaming markdown renderer
	 *
	 * Useful for rendering markdown as it's being generated by LLM.
	 *
	 * @example
	 * const renderer = MarkdownDisplay.createStreamRenderer();
	 * for await (const chunk of llmStream) {
	 *   renderer.addChunk(chunk);
	 * }
	 * renderer.finish();
	 */
	createStreamRenderer(): MarkdownStreamRenderer {
		return new MarkdownStreamRenderer();
	},

	/**
	 * Render markdown with custom options
	 */
	renderWithOptions(
		markdown: string,
		options: {
			width?: number;
			preserveNewlines?: boolean;
		},
	): string {
		initRenderer();

		// Temporarily override options if provided
		// biome-ignore lint/suspicious/noExplicitAny: Renderer options access
		const originalWidth = (renderer as any)?.options?.width;

		if (options.width && renderer) {
			// biome-ignore lint/suspicious/noExplicitAny: Renderer options override
			(renderer as any).options.width = options.width;
		}

		const result = MarkdownDisplay.render(markdown);

		// Restore original width
		if (originalWidth && renderer) {
			// biome-ignore lint/suspicious/noExplicitAny: Renderer options restore
			(renderer as any).options.width = originalWidth;
		}

		return result;
	},
};

/**
 * Streaming markdown renderer
 *
 * Accumulates chunks and renders complete markdown blocks as they arrive.
 * Strips ANSI codes to prevent escape sequences from corrupting markdown.
 */
export class MarkdownStreamRenderer {
	private buffer: string = "";
	private lastLineCount: number = 0;

	/**
	 * Strip ANSI escape codes from text
	 */
	private stripAnsi(text: string): string {
		return text.replace(ANSI_PATTERN, "");
	}

	/**
	 * Add a chunk of markdown text
	 */
	addChunk(chunk: string): void {
		// Strip ANSI codes before processing
		const cleanChunk = this.stripAnsi(chunk);
		this.buffer += cleanChunk;

		// Only render complete lines to avoid partial markdown constructs
		const lines = this.buffer.split("\n");
		const completeLines = lines.slice(0, -1); // All but last (potentially incomplete) line
		const newCompleteCount = completeLines.length;

		// Render new complete lines
		if (newCompleteCount > this.lastLineCount) {
			const linesToRender = completeLines.slice(this.lastLineCount);
			const markdownToRender = linesToRender.join("\n");

			if (markdownToRender.trim()) {
				try {
					const rendered = MarkdownDisplay.render(markdownToRender);
					process.stdout.write(rendered);
				} catch (_error) {
					// Fallback to plain text if markdown rendering fails
					process.stdout.write(`${markdownToRender}\n`);
				}
			}

			this.lastLineCount = newCompleteCount;
		}
	}

	/**
	 * Finish the stream and ensure all content is rendered
	 */
	finish(): void {
		// Render any remaining incomplete line
		const lines = this.buffer.split("\n");
		const lastLine = lines[lines.length - 1];

		if (lastLine?.trim()) {
			try {
				const rendered = MarkdownDisplay.render(lastLine);
				process.stdout.write(rendered);
			} catch (_error) {
				process.stdout.write(lastLine);
			}
		}

		process.stdout.write("\n");
	}

	/**
	 * Get the accumulated buffer
	 */
	getBuffer(): string {
		return this.buffer;
	}

	/**
	 * Clear the buffer and start fresh
	 */
	clear(): void {
		this.buffer = "";
		this.lastLineCount = 0;
	}
}
