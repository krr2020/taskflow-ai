/**
 * Init command - Initialize taskflow in a project
 */

import fs from "node:fs";
import path from "node:path";
import { BaseCommand, type CommandResult } from "@/commands/base";
import { ConfigLoader } from "@/lib/config/config-loader";
import { getProjectPaths, TEMPLATE_FILES } from "@/lib/config/config-paths";
import { VERSIONS } from "@/lib/config/constants";
import { Text } from "@/lib/ui/components";
import { ensureAllDirs } from "@/lib/utils/path-utils";
import { getTemplateDir } from "@/lib/utils/template-utils";
import {
	copyFile,
	ensureDir,
	exists,
	readJson,
	writeJson,
} from "../lib/utils/file-utils.js";

interface VersionInfo {
	templateVersion: string;
	installedAt: string;
	customized: string[];
}

interface PackageJson {
	name?: string;
	scripts?: Record<string, string>;
}

export class InitCommand extends BaseCommand {
	async execute(projectName?: string): Promise<CommandResult> {
		const configLoader = new ConfigLoader(this.context.projectRoot);

		// Check if already initialized
		if (configLoader.exists()) {
			return this.failure(
				this.getContent("INIT.ALREADY_INITIALIZED"),
				[
					"Configuration file already exists at: " +
						configLoader.getConfigPath(),
				],
				"Run 'taskflow status' to view your project state.",
			);
		}

		// Try to get project name from package.json, then use provided name, then fallback to directory name
		let detectedProjectName: string | undefined;

		const packageJsonPath = path.join(this.context.projectRoot, "package.json");
		if (exists(packageJsonPath)) {
			try {
				const packageJson = readJson(packageJsonPath) as PackageJson;
				detectedProjectName = packageJson?.name;
			} catch (_error) {
				// If package.json is invalid, continue to fallback
			}
		}

		const finalProjectName =
			projectName ||
			detectedProjectName ||
			path.basename(this.context.projectRoot);

		// Add task script to package.json if it exists
		if (exists(packageJsonPath)) {
			try {
				const packageJson = readJson(packageJsonPath) as PackageJson;
				if (packageJson) {
					if (!packageJson.scripts) {
						packageJson.scripts = {};
					}
					if (!packageJson.scripts.task) {
						packageJson.scripts.task = "taskflow";
						writeJson(packageJsonPath, packageJson);
					}
				}
			} catch (_error) {
				// If package.json is invalid or cannot be updated, continue
			}
		}

		// Create default configuration
		const config = ConfigLoader.createDefaultConfig(finalProjectName);
		configLoader.save(config);

		// Create directory structure
		const paths = getProjectPaths(this.context.projectRoot);

		// Create all directories
		ensureAllDirs(this.context.projectRoot);

		// Copy template files to .taskflow/ref/
		const templatesDir = getTemplateDir();

		let copiedFiles = 0;
		const fileDetails: string[] = [];

		// Copy protocol files
		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.protocols)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else {
					fileDetails.push(`  ⚠ Skipped: ${fileName} (template not found)`);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Copy PRD files
		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.prd)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else {
					fileDetails.push(`  ⚠ Skipped: ${fileName} (template not found)`);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Create project template files (coding-standards.md, architecture-rules.md)
		// SKIP: These should be generated by 'taskflow prd generate-arch' after PRD creation
		// to ensure they are project-specific and based on requirements.
		/*
		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.project)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					// Copy from template if available
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else if (DEFAULT_PLACEHOLDER_TEMPLATES[fileName]) {
					// Create placeholder from default template
					fs.writeFileSync(
						destPath,
						DEFAULT_PLACEHOLDER_TEMPLATES[fileName],
						"utf-8",
					);
					copiedFiles++;
					fileDetails.push(`  ✓ Created: ${fileName} (default placeholder)`);
				} else {
					// Log warning for missing template without default
					console.warn(
						`  ⚠ Skipped: ${fileName} (no template or default available)`,
					);
					fileDetails.push(
						`  ⚠ Skipped: ${fileName} (no template or default available)`,
					);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to create: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}
		*/

		// Copy retrospective file
		for (const [_key, sourcePath] of Object.entries(
			TEMPLATE_FILES.retrospective,
		)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else {
					fileDetails.push(`  ⚠ Skipped: ${fileName} (template not found)`);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Copy skill files
		const skillsDestDir = path.join(paths.refDir, "skills");
		ensureDir(skillsDestDir);

		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.skills)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, sourcePath);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: skills/${fileName}`);
				} else {
					fileDetails.push(
						`  ⚠ Skipped: skills/${fileName} (template not found)`,
					);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: skills/${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Create version file
		const versionFile = path.join(paths.taskflowDir, ".version");
		const versionInfo: VersionInfo = {
			templateVersion: VERSIONS.TEMPLATE,
			installedAt: new Date().toISOString(),
			customized: [],
		};
		writeJson(versionFile, versionInfo);

		// Manage .gitignore
		const gitignorePath = path.join(this.context.projectRoot, ".gitignore");
		const ignoreEntries = [
			"",
			"# TaskFlow",
			".taskflow/backups",
			".taskflow/logs",
			".taskflow/sessions",
			".taskflow/.version",
		];

		if (exists(gitignorePath)) {
			const content = fs.readFileSync(gitignorePath, "utf-8");
			const newEntries = ignoreEntries.filter(
				(entry) => entry && !content.includes(entry.trim()),
			);
			if (newEntries.length > 0) {
				fs.appendFileSync(gitignorePath, `${newEntries.join("\n")}\n`);
			}
		} else {
			fs.writeFileSync(gitignorePath, `${ignoreEntries.join("\n")}\n`);
		}

		// Build output message with file details
		const outputLines = [
			Text.success("Created taskflow.config.json"),
			Text.success("Created tasks/ directory"),
			Text.success("Created .taskflow/ref/ directory"),
			Text.success("Created .taskflow/logs/ directory"),
			exists(packageJsonPath)
				? Text.success("Added 'task' script to package.json")
				: "",
		].filter(Boolean);

		// Add template file details if any files were copied
		if (fileDetails.length > 0) {
			outputLines.push("");
			outputLines.push(Text.section(`Template Files (${copiedFiles})`));
			outputLines.push(...fileDetails);
		}

		// Add mode-specific output message
		outputLines.push("");
		outputLines.push(Text.success(this.getContent("INIT.SUCCESS")));

		// Get next steps and filter based on whether package.json exists
		const rawNextSteps = this.getContent("INIT.NEXT_STEPS");
		const nextStepsArray = Array.isArray(rawNextSteps)
			? rawNextSteps
			: [rawNextSteps];
		const nextSteps = nextStepsArray.filter((step) => {
			// Remove pnpm/npm commands if package.json doesn't exist
			if (!exists(packageJsonPath)) {
				return !step.includes("pnpm") && !step.includes("npm");
			}
			return true;
		});

		// Get AI guidance (will be filtered out automatically in manual mode)
		const aiGuidance = this.getContent("INIT.AI_GUIDANCE");
		const aiGuidanceStr =
			typeof aiGuidance === "string" ? aiGuidance : undefined;

		const options: { contextFiles: string[]; aiGuidance?: string } = {
			contextFiles: [
				".taskflow/ref/ai-protocol.md - Core AI operating discipline",
				".taskflow/ref/prd-generator.md - PRD creation guidelines",
				".taskflow/ref/task-generator.md - Task breakdown guidelines",
				".taskflow/ref/retrospective.md - Known error patterns",
			],
		};

		if (aiGuidanceStr) {
			options.aiGuidance = aiGuidanceStr;
		}

		return this.success(outputLines.join("\n"), nextSteps.join("\n"), options);
	}
}
