/**
 * Init command - Initialize taskflow in a project
 */

import path from "node:path";
import pc from "picocolors";
import { ConfigLoader } from "../lib/config-loader.js";
import { getProjectPaths, TEMPLATE_FILES } from "../lib/config-paths.js";
import { VERSIONS } from "../lib/constants.js";
import {
	copyFile,
	ensureDir,
	exists,
	readJson,
	writeJson,
} from "../lib/file-utils.js";
import { ensureAllDirs } from "../lib/path-utils.js";
import { getTemplateDir } from "../lib/template-utils.js";
import { TerminalFormatter } from "../lib/terminal-formatter.js";
import { BaseCommand, type CommandResult } from "./base.js";

interface VersionInfo {
	templateVersion: string;
	installedAt: string;
	customized: string[];
}

interface PackageJson {
	name?: string;
	scripts?: Record<string, string>;
}

export class InitCommand extends BaseCommand {
	async execute(projectName?: string): Promise<CommandResult> {
		const configLoader = new ConfigLoader(this.context.projectRoot);

		// Check if already initialized
		if (configLoader.exists()) {
			return this.failure(
				"Taskflow is already initialized in this project.",
				[
					"Configuration file already exists at: " +
						configLoader.getConfigPath(),
				],
				"Run 'taskflow status' to view your project state.",
			);
		}

		// Try to get project name from package.json, then use provided name, then fallback to directory name
		let detectedProjectName: string | undefined;

		const packageJsonPath = path.join(this.context.projectRoot, "package.json");
		if (exists(packageJsonPath)) {
			try {
				const packageJson = readJson(packageJsonPath) as PackageJson;
				detectedProjectName = packageJson?.name;
			} catch (_error) {
				// If package.json is invalid, continue to fallback
			}
		}

		const finalProjectName =
			projectName ||
			detectedProjectName ||
			path.basename(this.context.projectRoot);

		// Add task script to package.json if it exists
		if (exists(packageJsonPath)) {
			try {
				const packageJson = readJson(packageJsonPath) as PackageJson;
				if (packageJson) {
					if (!packageJson.scripts) {
						packageJson.scripts = {};
					}
					if (!packageJson.scripts.task) {
						packageJson.scripts.task = "taskflow";
						writeJson(packageJsonPath, packageJson);
					}
				}
			} catch (_error) {
				// If package.json is invalid or cannot be updated, continue
			}
		}

		// Create default configuration
		const config = ConfigLoader.createDefaultConfig(finalProjectName);
		configLoader.save(config);

		// Create directory structure
		const paths = getProjectPaths(this.context.projectRoot);

		// Create all directories
		ensureAllDirs(this.context.projectRoot);

		// Copy template files to .taskflow/ref/
		const templatesDir = getTemplateDir();

		let copiedFiles = 0;
		const fileDetails: string[] = [];

		// Copy protocol files
		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.protocols)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else {
					fileDetails.push(`  ⚠ Skipped: ${fileName} (template not found)`);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Copy PRD files
		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.prd)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else {
					fileDetails.push(`  ⚠ Skipped: ${fileName} (template not found)`);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Create project template files (coding-standards.md, architecture-rules.md)
		// SKIP: These should be generated by 'taskflow prd generate-arch' after PRD creation
		// to ensure they are project-specific and based on requirements.
		/*
		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.project)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					// Copy from template if available
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else if (DEFAULT_PLACEHOLDER_TEMPLATES[fileName]) {
					// Create placeholder from default template
					fs.writeFileSync(
						destPath,
						DEFAULT_PLACEHOLDER_TEMPLATES[fileName],
						"utf-8",
					);
					copiedFiles++;
					fileDetails.push(`  ✓ Created: ${fileName} (default placeholder)`);
				} else {
					// Log warning for missing template without default
					console.warn(
						`  ⚠ Skipped: ${fileName} (no template or default available)`,
					);
					fileDetails.push(
						`  ⚠ Skipped: ${fileName} (no template or default available)`,
					);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to create: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}
		*/

		// Copy retrospective file
		for (const [_key, sourcePath] of Object.entries(
			TEMPLATE_FILES.retrospective,
		)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, fileName);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: ${fileName}`);
				} else {
					fileDetails.push(`  ⚠ Skipped: ${fileName} (template not found)`);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: ${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Copy skill files
		const skillsDestDir = path.join(paths.refDir, "skills");
		ensureDir(skillsDestDir);

		for (const [_key, sourcePath] of Object.entries(TEMPLATE_FILES.skills)) {
			const fullSourcePath = path.join(templatesDir, sourcePath);
			const fileName = path.basename(sourcePath);
			const destPath = path.join(paths.refDir, sourcePath);

			try {
				if (exists(fullSourcePath)) {
					copyFile(fullSourcePath, destPath);
					copiedFiles++;
					fileDetails.push(`  ✓ Copied: skills/${fileName}`);
				} else {
					fileDetails.push(
						`  ⚠ Skipped: skills/${fileName} (template not found)`,
					);
				}
			} catch (error) {
				fileDetails.push(
					`  ✗ Failed to copy: skills/${fileName} - ${error instanceof Error ? error.message : String(error)}`,
				);
			}
		}

		// Create version file
		const versionFile = path.join(paths.taskflowDir, ".version");
		const versionInfo: VersionInfo = {
			templateVersion: VERSIONS.TEMPLATE,
			installedAt: new Date().toISOString(),
			customized: [],
		};
		writeJson(versionFile, versionInfo);

		// Build output message with file details
		const outputLines = [
			TerminalFormatter.success("Created taskflow.config.json"),
			TerminalFormatter.success("Created tasks/ directory"),
			TerminalFormatter.success("Created .taskflow/ref/ directory"),
			TerminalFormatter.success("Created .taskflow/logs/ directory"),
			exists(packageJsonPath)
				? TerminalFormatter.success("Added 'task' script to package.json")
				: "",
		].filter(Boolean);

		// Add template file details if any files were copied
		if (fileDetails.length > 0) {
			outputLines.push("");
			outputLines.push(
				TerminalFormatter.section(`Template Files (${copiedFiles})`),
			);
			outputLines.push(...fileDetails);
		}

		// Add context-specific guidance
		if (this.mcpContext.isMCP) {
			outputLines.push("");
			outputLines.push(
				TerminalFormatter.info("Running in MCP mode (AI-assisted)"),
			);
		} else {
			outputLines.push("");
			outputLines.push(TerminalFormatter.info("Running in direct CLI mode"));
			outputLines.push(pc.dim("Configure AI provider for generate commands:"));
			outputLines.push(
				pc.cyan(
					"   taskflow configure ai --provider <provider> --apiKey <key> --model <model>",
				),
			);
		}

		return this.success(
			outputLines.join("\n"),
			[
				"1. Create a PRD (Product Requirements Document):",
				"   Run: taskflow prd create <feature-name>",
				"   or:  pnpm task prd create <feature-name>",
				"",
				"2. Generate tasks from PRD:",
				"   Run: taskflow tasks generate <prd-file>",
				"   or:  pnpm task tasks generate <prd-file>",
				"",
				"3. Start working on tasks:",
				"   Run: taskflow next  (to find the next task)",
				"   Run: taskflow start <task-id>",
				"   or:  pnpm task next",
				"   or:  pnpm task start <task-id>",
			].join("\n"),
			{
				aiGuidance: [
					"You have initialized TaskFlow in this project.",
					"",
					"COMMAND USAGE:",
					"──────────────",
					"You can run taskflow commands in two ways:",
					"",
					"1. Direct command:",
					"   taskflow <command> <args>",
					"",
					"2. Via npm script (if package.json has 'task' script):",
					"   pnpm task <command> <args>",
					"   npm run task -- <command> <args>",
					"",
					"AI CONFIGURATION:",
					"─────────────────",
					"Some commands require AI for content generation:",
					"  - taskflow prd generate-arch: Generates coding-standards.md and architecture-rules.md",
					"  - taskflow tasks generate: Generates task breakdown from PRD",
					"",
					"If running via MCP/Factory AI:",
					"  → AI agent will automatically handle generation",
					"",
					"If running manually (CLI):",
					"  → You MUST configure an AI provider first:",
					"    taskflow configure ai --provider <provider> --apiKey <key> --model <model>",
					"",
					"NEXT: Create a PRD",
					"────────────────────",
					"A PRD (Product Requirements Document) defines what you're building.",
					"The AI will help you create it by:",
					"1. Reading .taskflow/ref/prd-generator.md for guidelines",
					"2. Gathering requirements through conversation",
					"3. Creating a structured PRD document",
					"",
					"Once the PRD is ready, TaskFlow will generate a task breakdown",
					"that you can execute step-by-step.",
				].join("\n"),
				contextFiles: [
					".taskflow/ref/ai-protocol.md - Core AI operating discipline",
					".taskflow/ref/prd-generator.md - PRD creation guidelines",
					".taskflow/ref/task-generator.md - Task breakdown guidelines",
					".taskflow/ref/retrospective.md - Known error patterns",
				],
				warnings: [
					"NEVER edit files in .taskflow/ or tasks/ directories directly",
					"ALWAYS use taskflow commands for task management",
					"Read ai-protocol.md before starting any task",
					"If running CLI manually, configure AI before using generate commands",
				],
			},
		);
	}
}
